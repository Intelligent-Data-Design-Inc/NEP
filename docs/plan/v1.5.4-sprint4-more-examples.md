# v1.5.4 Sprint 4 Implementation Plan: More Examples (coord/f_coord)

## Overview
- **Goal**: Create C and Fortran examples demonstrating 3D surface temperature data with lat, lon, and time coordinate variables following CF conventions
- **Sprint**: v1.5.4, Sprint 4
- **Primary Deliverables**:
  - C program `examples/classic/coord.c`
  - Fortran program `examples/f_classic/f_coord.f90`
  - CDL expected output files for both programs
  - CMake and Autotools build integration
  - CDL validation tests

## Prerequisites
- v1.5.4 Sprints 1–3 complete
- Existing examples infrastructure in place (BUILD_EXAMPLES option, validate_cdl.sh)
- `coord_vars.c` and `f_coord_vars.f90` already exist as reference patterns

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Time dimension | Fixed (`NTIME = 3`) | `unlimited_dim.c` already covers unlimited dims; keeps focus on 3D coordinate variables |
| NetCDF format | Classic (`NC_CLOBBER`) | Consistent with "classic" directory; no HDF5 dependency at runtime |
| Grid size | lat(4), lon(5), time(3) | Matches existing `coord_vars.c` scale; 60 total data values |
| CDL validation | Included | Final sprint; CDL infrastructure already exists |
| Time CF attributes | Full (`units`, `standard_name`, `long_name`, `axis`, `calendar`) | Most educational; demonstrates complete CF time convention |
| `coordinates` attribute | Yes, `coordinates = "time lat lon"` on sfc_temp | CF best practice; differentiates from `coord_vars.c` |

## Data Specification

### Dimensions
- `lat` = 4 (fixed)
- `lon` = 5 (fixed)
- `time` = 3 (fixed)

### Coordinate Variables

**lat(lat)** — float:
- Values: `{-45.0, -15.0, 15.0, 45.0}`
- Attributes:
  - `units = "degrees_north"`
  - `standard_name = "latitude"`
  - `long_name = "Latitude"`
  - `axis = "Y"`

**lon(lon)** — float:
- Values: `{-120.0, -60.0, 0.0, 60.0, 120.0}`
- Attributes:
  - `units = "degrees_east"`
  - `standard_name = "longitude"`
  - `long_name = "Longitude"`
  - `axis = "X"`

**time(time)** — float:
- Values: `{0.0, 6.0, 12.0}` (hours since epoch)
- Attributes:
  - `units = "hours since 2026-01-01"`
  - `standard_name = "time"`
  - `long_name = "Time"`
  - `axis = "T"`
  - `calendar = "standard"`

### Data Variable

**sfc_temp(time, lat, lon)** — float:
- Formula: `sfc_temp[t][i][j] = 280.0 + i * 2.0 + j * 0.5 + t * 1.0`
  - Where `i` = lat index (0–3), `j` = lon index (0–4), `t` = time index (0–2)
  - Produces values from 280.0 to 291.0 K (reasonable surface temperatures)
- Attributes:
  - `units = "K"`
  - `standard_name = "surface_temperature"`
  - `long_name = "Surface Temperature"`
  - `_FillValue = -999.0f`
  - `coordinates = "time lat lon"`

### Output File Names
- C: `coord.nc`
- Fortran: `f_coord.nc`

---

## Phase 1: C Program Implementation

### Task 1.1: Create coord.c with Doxygen Header
- **File path**: `examples/classic/coord.c`
- **Requirements**:
  - Comprehensive Doxygen header explaining:
    - Purpose: 3D surface temperature with time, lat, lon coordinate variables
    - Difference from `coord_vars.c`: adds time dimension, `coordinates` attribute, classic format
    - Learning objectives: 3D data, time coordinate variables, CF time conventions, `coordinates` attribute
    - Prerequisites: `coord_vars.c`
    - Related examples: `f_coord.f90`, `unlimited_dim.c`, `var4d.c`
    - Compilation and usage instructions
    - Expected output description
  - Author: `Edward Hartnett, Intelligent Data Design, Inc.`
  - Date: `2026`
- **Acceptance criteria**:
  - Doxygen-compatible documentation
  - Clear explanation suitable for NetCDF beginners

### Task 1.2: Implement Write Phase
- **Requirements**:
  - Include headers: `<stdio.h>`, `<stdlib.h>`, `<string.h>`, `<netcdf.h>`
  - Define constants: `FILE_NAME "coord.nc"`, `NLAT 4`, `NLON 5`, `NTIME 3`, `NDIMS 3`
  - Define ERR macro matching existing pattern: `#define ERR(e) {printf("Error: %s\n", nc_strerror(e)); exit(ERRCODE);}`
  - Create file with `nc_create(FILE_NAME, NC_CLOBBER, &ncid)` — classic format
  - Define 3 dimensions: `time`, `lat`, `lon`
  - Define 3 coordinate variables: `time(time)`, `lat(lat)`, `lon(lon)` — all `NC_FLOAT`
  - Add CF attributes to all coordinate variables (see Data Specification above)
  - Define `sfc_temp(time, lat, lon)` as `NC_FLOAT` with 3 dimensions
  - Add CF attributes to `sfc_temp` including `coordinates = "time lat lon"`
  - End define mode with `nc_enddef()`
  - Initialize and write coordinate data arrays
  - Initialize sfc_temp using formula: `280.0 + i * 2.0 + j * 0.5 + t * 1.0`
  - Write all variables with `nc_put_var_float()`
  - Close file with `nc_close()`
  - Print success message
- **Dimension ordering in C**: `dimids[3] = {time_dimid, lat_dimid, lon_dimid}` → `sfc_temp[NTIME][NLAT][NLON]`
- **Acceptance criteria**:
  - File created in classic format
  - All 3 dimensions, 4 variables, and all attributes written correctly
  - Data values match formula

### Task 1.3: Implement Read/Validate Phase
- **Requirements**:
  - Reopen file with `nc_open(FILE_NAME, NC_NOWRITE, &ncid)`
  - Verify metadata:
    - `ndims == 3`
    - `nvars == 4` (time, lat, lon, sfc_temp)
  - Verify dimension names and sizes using `nc_inq_dim()`
  - Verify coordinate variable attributes:
    - lat: `units`, `standard_name`, `axis`
    - lon: `units`, `standard_name`, `axis`
    - time: `units`, `standard_name`, `axis`, `calendar`
  - Verify sfc_temp attributes: `units`, `_FillValue`, `coordinates`
  - Read back all coordinate arrays and verify values match
  - Read back sfc_temp array and verify all 60 values match
  - Print verification messages for each check
  - Close file
  - Return 0 on success, exit with ERRCODE on failure
- **Acceptance criteria**:
  - All metadata validated
  - All data values validated
  - Clear output messages
  - Exit code 0 on success

---

## Phase 2: Fortran Program Implementation

### Task 2.1: Create f_coord.f90 with Doxygen Header
- **File path**: `examples/f_classic/f_coord.f90`
- **Requirements**:
  - Fortran Doxygen header (using `!>` and `!!` comment style)
  - Explain this is the Fortran equivalent of `coord.c`
  - Note Fortran-specific considerations:
    - Column-major array ordering: `sfc_temp(NLON, NLAT, NTIME)` vs C `sfc_temp[NTIME][NLAT][NLON]`
    - Dimension order in `nf90_def_var`: reversed from C (`lon_dimid, lat_dimid, time_dimid`)
    - 1-based indexing
  - Author: `Edward Hartnett, Intelligent Data Design, Inc.`
  - Date: `2026`
- **Acceptance criteria**:
  - Doxygen-compatible documentation
  - Fortran-specific notes included

### Task 2.2: Implement Write Phase (Fortran)
- **Requirements**:
  - `use netcdf` and `implicit none`
  - Parameters: `FILE_NAME = "f_coord.nc"`, `NLAT = 4`, `NLON = 5`, `NTIME = 3`
  - Create file with `nf90_create(FILE_NAME, NF90_CLOBBER, ncid)` — classic format
  - Define 3 dimensions: `time`, `lat`, `lon`
  - Define coordinate variables using `nf90_def_var()` with scalar dimension IDs
  - Add CF attributes using `nf90_put_att()` — Fortran handles string length automatically
  - Define `sfc_temp` with `dimids = (/lon_dimid, lat_dimid, time_dimid/)` (Fortran reversed order)
  - Add attributes including `coordinates = "time lat lon"`
  - End define mode with `nf90_enddef()`
  - Initialize data arrays:
    - `sfc_temp(j, i, t) = 280.0 + (i-1) * 2.0 + (j-1) * 0.5 + (t-1) * 1.0` (1-based indexing)
  - Write all variables with `nf90_put_var()`
  - Close file with `nf90_close()`
  - Error handling via `handle_err` subroutine in `contains` block
- **Acceptance criteria**:
  - Produces identical NetCDF file to C version (verified by ncdump)
  - Fortran array ordering handled correctly

### Task 2.3: Implement Read/Validate Phase (Fortran)
- **Requirements**:
  - Mirror C validation logic using `nf90_*` inquiry functions
  - Verify dimensions, variables, attributes, and data
  - Use `trim()` for string comparisons
  - Print verification messages
  - `stop 2` on failure, normal exit on success
- **Acceptance criteria**:
  - All metadata and data validated
  - Output matches C version's validation pattern

---

## Phase 3: CDL Expected Output Files

### Task 3.1: Create coord_expected.cdl
- **File path**: `examples/expected_output/coord_expected.cdl`
- **Requirements**:
  - Generate by running `coord` and capturing `ncdump coord.nc` output
  - Must match the exact data specification above
  - Classic format header (no `_nc4_non_classic` group)
- **Expected content**:
```
netcdf coord {
dimensions:
	time = 3 ;
	lat = 4 ;
	lon = 5 ;
variables:
	float time(time) ;
		time:units = "hours since 2026-01-01" ;
		time:standard_name = "time" ;
		time:long_name = "Time" ;
		time:axis = "T" ;
		time:calendar = "standard" ;
	float lat(lat) ;
		lat:units = "degrees_north" ;
		lat:standard_name = "latitude" ;
		lat:long_name = "Latitude" ;
		lat:axis = "Y" ;
	float lon(lon) ;
		lon:units = "degrees_east" ;
		lon:standard_name = "longitude" ;
		lon:long_name = "Longitude" ;
		lon:axis = "X" ;
	float sfc_temp(time, lat, lon) ;
		sfc_temp:units = "K" ;
		sfc_temp:standard_name = "surface_temperature" ;
		sfc_temp:long_name = "Surface Temperature" ;
		sfc_temp:_FillValue = -999.f ;
		sfc_temp:coordinates = "time lat lon" ;
data:

 time = 0, 6, 12 ;

 lat = -45, -15, 15, 45 ;

 lon = -120, -60, 0, 60, 120 ;

 sfc_temp =
  280, 280.5, 281, 281.5, 282,
  282, 282.5, 283, 283.5, 284,
  284, 284.5, 285, 285.5, 286,
  286, 286.5, 287, 287.5, 288,
  281, 281.5, 282, 282.5, 283,
  283, 283.5, 284, 284.5, 285,
  285, 285.5, 286, 286.5, 287,
  287, 287.5, 288, 288.5, 289,
  282, 282.5, 283, 283.5, 284,
  284, 284.5, 285, 285.5, 286,
  286, 286.5, 287, 287.5, 288,
  288, 288.5, 289, 289.5, 290 ;
}
```
- **Note**: The exact CDL output must be generated from the actual program run, not hand-crafted. The above is an approximation — actual ncdump formatting may differ slightly. Build the program first, run ncdump, and capture the output.
- **Acceptance criteria**:
  - CDL file matches actual ncdump output exactly

### Task 3.2: Create f_coord_expected.cdl
- **File path**: `examples/expected_output/f_coord_expected.cdl`
- **Requirements**:
  - Generate by running `f_coord` and capturing `ncdump f_coord.nc` output
  - Should be identical to `coord_expected.cdl` except for the `netcdf` header line (`netcdf f_coord {`)
  - Classic format produces identical output regardless of C/Fortran source
- **Acceptance criteria**:
  - CDL file matches actual ncdump output exactly
  - Data values identical to C version

---

## Phase 4: CMake Build Integration

### Task 4.1: Update examples/classic/CMakeLists.txt
- **File path**: `examples/classic/CMakeLists.txt`
- **Changes**:
  - Add `coord` to `CLASSIC_EXAMPLES` list
  - Add CDL validation test:
    ```cmake
    add_test(NAME coord_validate 
             COMMAND bash validate_cdl.sh coord coord.nc 
                     ${CMAKE_CURRENT_SOURCE_DIR}/../expected_output/coord_expected.cdl)
    set_tests_properties(coord_validate PROPERTIES DEPENDS coord_run)
    ```
- **Acceptance criteria**:
  - `coord` builds and runs as CTest test
  - CDL validation test runs after `coord_run`

### Task 4.2: Update examples/f_classic/CMakeLists.txt
- **File path**: `examples/f_classic/CMakeLists.txt`
- **Changes**:
  - Add `f_coord` to `F_CLASSIC_EXAMPLES` list
  - Add CDL validation test:
    ```cmake
    add_test(NAME f_coord_validate 
             COMMAND bash validate_cdl.sh f_coord f_coord.nc 
                     ${CMAKE_CURRENT_SOURCE_DIR}/../expected_output/f_coord_expected.cdl)
    set_tests_properties(f_coord_validate PROPERTIES DEPENDS f_coord_run)
    ```
- **Acceptance criteria**:
  - `f_coord` builds and runs as CTest test (when ENABLE_FORTRAN=ON)
  - CDL validation test runs after `f_coord_run`

---

## Phase 5: Autotools Build Integration

### Task 5.1: Update examples/classic/Makefile.am
- **File path**: `examples/classic/Makefile.am`
- **Changes**:
  - Add `coord` to `check_PROGRAMS`
  - Add `coord_SOURCES = coord.c`
  - Create `test_coord.sh` test wrapper script
  - Add `test_coord.sh` to `TESTS` and `EXTRA_DIST`
- **test_coord.sh content**:
  ```bash
  #!/bin/bash
  set -e
  ./coord
  bash ../validate_cdl.sh coord coord.nc ../expected_output/coord_expected.cdl
  ```
- **Acceptance criteria**:
  - `coord` builds during `make check`
  - Test script runs and validates CDL output

### Task 5.2: Update examples/f_classic/Makefile.am
- **File path**: `examples/f_classic/Makefile.am`
- **Changes**:
  - Add `f_coord` to `check_PROGRAMS`
  - Add `f_coord_SOURCES = f_coord.f90`
  - Create `test_f_coord.sh` test wrapper script
  - Add `test_f_coord.sh` to `TESTS` and `EXTRA_DIST`
- **test_f_coord.sh content**:
  ```bash
  #!/bin/bash
  set -e
  ./f_coord
  bash ../validate_cdl.sh f_coord f_coord.nc ../expected_output/f_coord_expected.cdl
  ```
- **Acceptance criteria**:
  - `f_coord` builds during `make check` (when Fortran enabled)
  - Test script runs and validates CDL output

---

## Phase 6: Documentation Updates

### Task 6.1: Update examples/README.md
- **File path**: `examples/README.md`
- **Changes**:
  - Add `coord.c` to classic examples list with description:
    "3D surface temperature with time, latitude, and longitude coordinate variables following CF conventions"
  - Add `f_coord.f90` to Fortran classic examples list with equivalent description
- **Acceptance criteria**:
  - README updated with both new examples

---

## Phase 7: Testing and Validation

### Task 7.1: Manual Testing
- Build and run both programs manually
- Run `ncdump coord.nc` and `ncdump f_coord.nc`
- Verify CDL output matches expected files
- Verify data values follow the formula

### Task 7.2: Build System Testing
- Test CMake build with `BUILD_EXAMPLES=ON` — both programs build and tests pass
- Test CMake build with `BUILD_EXAMPLES=OFF` — programs not built
- Test Autotools build with `--enable-examples` — both programs build and `make check` passes
- Test Autotools build with `--disable-examples` — programs not built
- Test CMake with `ENABLE_FORTRAN=OFF` — only C program builds

### Task 7.3: CI Validation
- Verify both programs run in CI for CMake and Autotools builds
- Verify CDL validation tests pass in CI
- No new warnings or errors

---

## Definition of Done
- [ ] `coord.c` created in `examples/classic/`
- [ ] `f_coord.f90` created in `examples/f_classic/`
- [ ] Both programs create NetCDF file with 3 dimensions (time=3, lat=4, lon=5)
- [ ] Both programs define 4 variables (time, lat, lon, sfc_temp)
- [ ] All CF convention attributes present (including `coordinates` on sfc_temp)
- [ ] Both programs write coordinate and data arrays
- [ ] Both programs reopen file and validate all contents
- [ ] Both programs return 0 on success, non-zero on failure
- [ ] Comprehensive Doxygen documentation on both programs
- [ ] `coord_expected.cdl` and `f_coord_expected.cdl` generated and stored
- [ ] CMake build integration complete (both programs + CDL validation)
- [ ] Autotools build integration complete (both programs + CDL validation)
- [ ] Test wrapper scripts created (`test_coord.sh`, `test_f_coord.sh`)
- [ ] `examples/README.md` updated
- [ ] C and Fortran programs produce identical NetCDF output (verified by ncdump)
- [ ] Tests pass in both build systems
- [ ] CI passes with new examples

## Technical Notes
- **File names**: `coord.nc` (C), `f_coord.nc` (Fortran)
- **Format**: Classic NetCDF (NC_CLOBBER, no NC_NETCDF4 flag)
- **Dimensions**: time=3, lat=4, lon=5 (60 total sfc_temp values)
- **Data formula**: `sfc_temp = 280.0 + lat_idx * 2.0 + lon_idx * 0.5 + time_idx * 1.0`
- **Temperature range**: 280.0 K to 290.0 K (reasonable surface temperatures)
- **Coordinate values**: lat {-45, -15, 15, 45}, lon {-120, -60, 0, 60, 120}, time {0, 6, 12} hours
- **Error handling**: ERR macro (C), handle_err subroutine (Fortran)
- **Exit codes**: 0=success, 2=error
- **Fortran array order**: `sfc_temp(NLON, NLAT, NTIME)` with `dimids = (/lon_dimid, lat_dimid, time_dimid/)`
- **Key difference from coord_vars.c**: Adds time dimension, `coordinates` attribute, uses classic format

## Expected ncdump Output (approximate)
```
netcdf coord {
dimensions:
	time = 3 ;
	lat = 4 ;
	lon = 5 ;
variables:
	float time(time) ;
		time:units = "hours since 2026-01-01" ;
		time:standard_name = "time" ;
		time:long_name = "Time" ;
		time:axis = "T" ;
		time:calendar = "standard" ;
	float lat(lat) ;
		lat:units = "degrees_north" ;
		lat:standard_name = "latitude" ;
		lat:long_name = "Latitude" ;
		lat:axis = "Y" ;
	float lon(lon) ;
		lon:units = "degrees_east" ;
		lon:standard_name = "longitude" ;
		lon:long_name = "Longitude" ;
		lon:axis = "X" ;
	float sfc_temp(time, lat, lon) ;
		sfc_temp:units = "K" ;
		sfc_temp:standard_name = "surface_temperature" ;
		sfc_temp:long_name = "Surface Temperature" ;
		sfc_temp:_FillValue = -999.f ;
		sfc_temp:coordinates = "time lat lon" ;
data:

 time = 0, 6, 12 ;

 lat = -45, -15, 15, 45 ;

 lon = -120, -60, 0, 60, 120 ;

 sfc_temp =
  280, 280.5, 281, 281.5, 282,
  282, 282.5, 283, 283.5, 284,
  284, 284.5, 285, 285.5, 286,
  286, 286.5, 287, 287.5, 288,
  281, 281.5, 282, 282.5, 283,
  283, 283.5, 284, 284.5, 285,
  285, 285.5, 286, 286.5, 287,
  287, 287.5, 288, 288.5, 289,
  282, 282.5, 283, 283.5, 284,
  284, 284.5, 285, 285.5, 286,
  286, 286.5, 287, 287.5, 288,
  288, 288.5, 289, 289.5, 290 ;
}
```

**Note**: Exact CDL formatting (especially float precision) must be verified by running the actual program and ncdump. The above is the target — actual output may show values like `280.5` or `2.805e+02` depending on ncdump version.

## References
- Existing pattern: `examples/classic/coord_vars.c` and `examples/f_classic/f_coord_vars.f90`
- CDL validation: `examples/validate_cdl.sh`
- CF Conventions: http://cfconventions.org/Data/cf-conventions/cf-conventions-1.11/cf-conventions.html
- NetCDF-C Classic API: https://docs.unidata.ucar.edu/netcdf-c/current/classic_api.html
- v1.5.3 Sprint 1 plan for implementation pattern reference

## Risk Assessment
- **CDL float formatting**: ncdump may format float values differently than expected (e.g., `280.` vs `280` vs `2.8e+02`). Mitigation: generate CDL from actual program output, not hand-crafted.
- **Classic format limitations**: Classic format doesn't support `NC_INT64` or unsigned types, but this example only uses `NC_FLOAT` so no issue.
- **Fortran/C output equivalence**: Array ordering differences could cause data mismatch. Mitigation: careful dimension ordering in Fortran (`dimids = (/lon, lat, time/)`) and array indexing (`sfc_temp(j, i, t)`).
