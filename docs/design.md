# NFEP – GRIB2 VOL Connector

This repository contains a *minimal* HDF5 **V**irtual **O**bject **L**ayer (VOL) connector that can be used as a starting point for new connectors.  The current implementation is hard-coded for demonstration purposes only – it does **not** perform any real GRIB2 I/O – but the scaffolding mirrors that of a production-grade plugin.

The project can be built either with **CMake** (preferred) or with the legacy **Autotools** files that are kept for environments where CMake is not available.  A GitHub Actions workflow (see `.github/workflows/ci.yml`) validates both the build and the unit-tests on every push.


## Directory layout

```
/                    Project root
├── .github/         CI/CD configuration (GitHub Actions)
├── cmake/           Extra CMake helper modules (future use)
├── src/             The GRIB2 VOL connector implementation
│   ├── grib2_vol_connector.c
│   └── grib2_vol_connector.h
├── test/            Unit and integration tests for the VOL
│   ├── vol_plugin.c           – functional tests
│   ├── test_vol_plugin.sh.in  – driver script used by CTest/Automake
│   └── …
├── docs/            Project documentation
│   ├── design.md    – *this* document
│   └── Doxyfile.in  – template for autogenerated API docs
├── CMakeLists.txt   Top-level CMake entry point
├── configure.ac     Autotools entry point (fallback)
└── ...
```


The project is structured as follows:
The `examples/` directory referenced in earlier revisions has been removed – example usage now lives inside `test/` so that it is automatically compiled and executed by both build systems.


## Connector design

The connector is registered with the HDF5 library via the normal plugin mechanism (`H5PLget_plugin_type` / `H5PLget_plugin_info`).  The exported `H5VL_class_t` structure is intentionally populated with `NULL` callbacks – this keeps the shared‐library tiny while still exercising the full registration path used by real connectors.

To adopt this template for a *real* connector simply replace the `NULL` entries with your own function pointers and add any private data structures that you need.

Key predefined macros:

* `GRIB2_VOL_CONNECTOR_NAME`  – human readable name shown by the HDF5 API
* `GRIB2_VOL_CONNECTOR_VALUE` – unique numeric ID in the reserved plugin range `(256-65535)`


## Building

### CMake (recommended)

```bash
mkdir build && cd build
CC=mpicc cmake .. -DCMAKE_PREFIX_PATH=/path/to/hdf5
make -j$(nproc)
make test      # run CTest suite
sudo make install
```

### Autotools

```bash
./bootstrap            # only needed when cloning from Git
./configure --with-hdf5=/path/to/hdf5 CC=mpicc
make -j$(nproc)
make check             # run Automake test-suite
make install
```

Both build systems honour `CC`, `CFLAGS`, `PREFIX`, etc., so they integrate well with package managers such as **Spack** or **Conda-Forge**.

## Continuous Integration

The workflow in `.github/workflows/ci.yml` compiles the connector on Ubuntu, builds a fresh copy of **HDF5 1.14.5**, and executes the tests.  Highlights:

1. Re-use a cached HDF5 install to speed up subsequent runs.
2. Configure CMake with `CC=mpicc` to enable MPI.
3. Generate HTML API documentation with **Doxygen** via the `doxygen` target.

## Documentation

API reference is generated with Doxygen (`docs/Doxyfile.in`) and placed in `build/docs/doxygen`.  Invoke with:

```bash
cmake --build build --target doxygen
```

## Testing

* **vol_plugin.c** – exercises connector registration & teardown.
* **test_vol_plugin.sh.in** – wrapper used by both CTest and Automake.

## Future work

This template is deliberately minimal.  Potential next steps:

* Implement real GRIB2 read/write callbacks.
* Add performance benchmarks via `h5perf`.
* Ship a sample Python wrapper using `h5py`’s VOL plugin support.

---

*Last updated: 2025-07-05*


